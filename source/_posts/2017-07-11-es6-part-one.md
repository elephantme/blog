---
title: 深入理解ES6
date: 2017-07-11 23:26:39
tags: ES6
categories: ES6
---

# 块级作用域绑定

## var声明及变量提升（Hoisting）机制

通过关键字var声明的变量，无论是在哪声明的，都会被提升到当前作用域的顶部，而初始化操作依旧留在原处执行。

## 块级声明

块级声明用于声明在指定块的作用域之外无法访问的变量。块级作用域（词法作用域）存在于：
  * 函数内部
  * 块中（{}之间的区域）

### let声明

声明变量
变量作用域限定在当前代码块中
声明不会被提升
同一作用域中不能重复声明

### const声明

声明常量，一旦设定变不可更改（意味着不能重新赋值，如果声明的是对象，对象属性值是可以修改的）
所声明的常量必须进行初始化
声明不会被提升
同一作用域中不能重复声明

### 临时死区（Temporal Dead Zone）

Javascript 引擎在扫描代码发现变量声明时，要么将它们提升至作用域顶部（遇到 var 声明），要么将声明放到TDZ中（遇到 let 和 const 声明）。访问TDZ中的变量会触发运行时错误。只有执行过变量声明语句后，变量才会从TDZ中移出，然后方可正常访问。

```javascript
if(condition){
  console.log(typeof value); // 引用错误！
  let value = "a";
}
```
是因为value在TDZ中，即使不易出错的typeof也无法阻挡引擎抛出错误。

```javascript
console.log(typeof value); // "undefined"
if(condition){
  let value = "a";
}
```
是因为typeof value是在TDZ外执行的。

## 循环中的块作用域绑定

### 循环中的let声明

每次迭代循环都创建一个新变量，并以之前迭代中同名变量的值将其初始化。而 var 每次迭代同时共享着变量。还是把经典的例子拿出来吧

```javascript
var funcs = [];

for(var i=0; i<10; i++){
  funcs.push(function(){
    console.log(i);
  });
}

funcs.forEach(function(func){
  func();  // 输出10次10
});
```

上面例子只需把var 修改为 let 就可以像期望的那样运行，输出 0,1,2直到9

### 循环中const声明

普通for循环中，可以在初始化变量时使用const，但是更改这个变量的值就会抛出错误。
在for-in 或 for-of 中使用const的行为与使用let一致，是因为每次迭代不会修改已有绑定，而是创建一个新绑定。

## 全局作用域绑定

var被用于全局作用域时，它会创建一个新的全局变量作为全局对象（浏览器环境中的window对象）的属性。因此它会覆盖全局变量。

如果在全局作用域中使用let或者const，会在全局作用域下创建一个新的绑定，但该绑定不会添加为全局对象的属性。因此不会覆盖全局变量。

```javascript
var RegExp = "hello";
console.log(window.RegExp); //hello
```

```javascript
let RegExp = "hello";
console.log(RegExp);        //"hello"
console.log(window.RegExp); //undefined
```

## 块级绑定最佳实践的进化

默认使用const，只有确实需要改变变量的值时使用let。因为大部分变量的值在初始化不应再改变，而预料外的变量值的改变是很多bug的源头。

# 字符串和正则表达式

# 函数

# 扩展对象的功能性

# 解构：使数据访问更便捷



